// Copyright Â© 2017 Tom Whiston <tom.whiston@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"bufio"
	"bytes"
	"errors"
	"github.com/spf13/cobra"
	"github.com/twhiston/pb/pb"
	"gopkg.in/yaml.v2"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// renderCmd represents the render command
var renderCmd = &cobra.Command{
	Use:   "render",
	Short: "Render a patchblock.xml file from a .yml and (optional) .c file",
	Long:  `Takes files generated by the new command and turns them into an .xml file which can be read by patchblocks`,
	RunE: func(cmd *cobra.Command, args []string) error {

		confFile, err := cmd.PersistentFlags().GetString("cfg")
		if err != nil {
			return err
		}
		if confFile == "" {
			//If no explicit conf file go looking for one
			//Because the file is named after the block we cannot predict it, so we just try to find if there is 1 yml in this folder
			configs := checkExt(".yml")
			if len(configs) > 1 {
				return errors.New("More than 1 .yml file in this folder, config is ambiguous, please use the --cfg option to specify")
			}
			confFile = configs[0]
		} else {
			//If we were given a file we should test that it really exists
			if _, err := os.Stat(confFile); os.IsNotExist(err) {
				return errors.New("Config file could not be found")
			}
		}

		//If we got this far we can try to Unmarshal the config file
		cfg := new(pb.Config)

		dat, err := ioutil.ReadFile(confFile)
		if err != nil {
			return err
		}
		err = yaml.Unmarshal([]byte(dat), cfg)
		if err != nil {
			return err
		}

		//Set the lowercase block name for the xml renderer
		cfg.BlockNameLower = strings.ToLower(cfg.Name)

		if cfg.Code.Block != "" {
			return errors.New("Block parsing not implemented yet")
		}
		//Parse the .c file
		if _, err := os.Stat(cfg.Code.Path); os.IsNotExist(err) {
			return errors.New(".c file could not be found")
		}

		file, err := os.Open(cfg.Code.Path)
		if err != nil {
			return err
		}
		defer file.Close()

		scanner := bufio.NewScanner(file)
		extractActive := false
		var code []string
		for scanner.Scan() {
			//This is a bit crude but basically we are looking to extract everything after the line with the function definition in
			lineTxt := scanner.Text()
			if extractActive {
				code = append(code, lineTxt)
			}
			if strings.Contains(lineTxt, "static inline void") {
				extractActive = true
			}
		}

		if scanner.Err() != nil {
			return err
		}

		//Check that the last line of the file is the closing of the function, if not error out
		for {
			if code[len(code)-1] == "" {
				code = code[:len(code)-1]
			} else {
				break
			}
		}

		final := strings.TrimSpace(code[len(code)-1])
		if final != "}" {
			return errors.New("Last line of code file must ONLY contain a closing bracket")
		}
		code = code[:len(code)-1]

		//We now only have the pure c function call and none of the surrounding wrapper
		//Parse the pb macros that may be used in the function and replace them with inline code
		//TODO - This raises an interesting point. Should the macros be GENERATED by go too?
		// We need them to be in code because we need to look for x() and replace it with render(x())
		// which is the full function code. If we need to store this in golang then could we generate it?
		// or should we just try to find it in a file somewhere? that is more error prone imo

		//Render the template
		for _, v := range code {
			log.Println(v)
		}

		cfg.InternalTemplateData.ParsedFunction = code

		buf := bytes.NewBuffer(*new([]byte))

		renderXMLTemplate(buf, cfg)
		if err != nil {
			return err
		}
		return ioutil.WriteFile(cfg.Name+".xml", buf.Bytes(), 0644)
	},
}

func checkExt(ext string) []string {
	pathS, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	var files []string
	filepath.Walk(pathS, func(path string, f os.FileInfo, _ error) error {
		if !f.IsDir() {
			r, err := regexp.MatchString(ext, f.Name())
			if err == nil && r {
				files = append(files, f.Name())
			}
		}
		return nil
	})
	return files
}

func init() {
	RootCmd.AddCommand(renderCmd)

	//renderCmd.PersistentFlags().String("dir", "", "A directory to generate a block (or blocks from). Defaults to cwd. If set this overrides conf and c flags")
	renderCmd.PersistentFlags().String("cfg", "", "A config yml to generate a block from")
	//renderCmd.PersistentFlags().String("c", "", "Set the c file that the block will use. Of blank looks for a file called ")

}
