// Copyright Â© 2017 Tom Whiston <tom.whiston@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"bufio"
	"bytes"
	"encoding/xml"
	"errors"
	"github.com/spf13/cobra"
	"github.com/twhiston/pb/pb"
	"gopkg.in/yaml.v2"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// renderCmd represents the render command
var renderCmd = &cobra.Command{
	Use:   "render",
	Short: "Render a patchblock.xml file from a .yml and (optional) .c file",
	Long:  `Takes files generated by the new command and turns them into an .xml file which can be read by patchblocks`,
	RunE: func(cmd *cobra.Command, args []string) error {

		confFile, err := cmd.PersistentFlags().GetString("cfg")
		if err != nil {
			return err
		}
		if confFile == "" {
			//If no explicit conf file go looking for one
			//Because the file is named after the block we cannot predict it, so we just try to find if there is 1 yml in this folder
			configs := checkExt(".yml")
			if len(configs) > 1 {
				return errors.New("More than 1 .yml file in this folder, config is ambiguous, please use the --cfg option to specify")
			}
			confFile = configs[0]
		} else {
			//If we were given a file we should test that it really exists
			if _, err := os.Stat(confFile); os.IsNotExist(err) {
				return errors.New("Config file could not be found")
			}
		}

		//If we got this far we can try to Unmarshal the config file
		cfg := new(pb.Config)

		dat, err := ioutil.ReadFile(confFile)
		if err != nil {
			return err
		}
		err = yaml.Unmarshal([]byte(dat), cfg)
		if err != nil {
			return err
		}

		//Set the lowercase block name for the xml renderer
		cfg.BlockNameLower = strings.ToLower(cfg.Name)

		if cfg.Code.Block != "" {
			return errors.New("Block parsing not implemented yet")
		}
		//Parse the .c file
		if _, err := os.Stat(cfg.Code.Path); os.IsNotExist(err) {
			return errors.New(".c file could not be found")
		}

		file, err := os.Open(cfg.Code.Path)
		if err != nil {
			return err
		}
		defer file.Close()

		scanner := bufio.NewScanner(file)
		extractActive := false
		var code []string
		for scanner.Scan() {
			//This is a bit crude but basically we are looking to extract everything after the line with the function definition in
			lineTxt := scanner.Text()
			if extractActive {
				code = append(code, lineTxt)
			}
			if strings.Contains(lineTxt, "static inline void") {
				extractActive = true
			}
		}

		if scanner.Err() != nil {
			return err
		}

		//Check that the last line of the file is the closing of the function, if not error out
		for {
			if code[len(code)-1] == "" {
				code = code[:len(code)-1]
			} else {
				break
			}
		}

		final := strings.TrimSpace(code[len(code)-1])
		if final != "}" {
			return errors.New("last line of code file must ONLY contain a closing bracket")
		}
		code = code[:len(code)-1]

		//Merge in the macros
		macroFilePaths, err := cmd.PersistentFlags().GetStringArray("macro")
		if err != nil {
			return err
		}
		for _, v := range macroFilePaths {
			mf, err := loadMacroFile(v)
			if err != nil {
				log.Println(err)
				continue
			}
			//prepend to code
			code = append(mf, code...)
		}

		//Render the template
		cfg.InternalTemplateData.ParsedFunction = code
		cfg.Help = strings.TrimSpace(cfg.Help)

		buf := bytes.NewBuffer(*new([]byte))

		renderXMLTemplate(buf, cfg)
		if err != nil {
			return err
		}
		return ioutil.WriteFile(cfg.Name+".xml", buf.Bytes(), 0644)
	},
}

func loadMacroFile(filePath string) ([]string, error) {
	content, err := ioutil.ReadFile(filePath)
	if err != nil {
		return []string{}, err
	}
	lines := strings.Split(string(content), "\n")
	return lines, nil
}

func checkExt(ext string) []string {
	pathS, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	var files []string
	filepath.Walk(pathS, func(path string, f os.FileInfo, _ error) error {
		if !f.IsDir() {
			r, err := regexp.MatchString(ext, f.Name())
			if err == nil && r {
				files = append(files, f.Name())
			}
		}
		return nil
	})
	return files
}

// confCmd represents the conf command
var confCmd = &cobra.Command{
	Use:   "conf",
	Short: "Generate a set of pb conf files from a block xml file",
	Long:  ``,
	RunE: func(cmd *cobra.Command, args []string) error {
		log.Println("conf called")

		confFile, err := cmd.Flags().GetString("xml")
		if err != nil {
			return err
		}
		if confFile == "" {
			//If no explicit conf file go looking for one
			//Because the file is named after the block we cannot predict it, so we just try to find if there is 1 yml in this folder
			configs := checkExt(".xml")
			if len(configs) > 1 {
				return errors.New("More than 1 .xml file in this folder, config is ambiguous, please use the --xml option to specify")
			}
			confFile = configs[0]
		} else {
			//If we were given a file we should test that it really exists
			if _, err := os.Stat(confFile); os.IsNotExist(err) {
				return errors.New("Config file could not be found")
			}
		}

		//If we got this far we can try to Unmarshal the config file
		cfg := new(pb.XMLConfig)
		dat, err := ioutil.ReadFile(confFile)
		if err != nil {
			return err
		}
		err = xml.Unmarshal(dat, &cfg)
		if err != nil {
			return err
		}

		// At this point we have our horrible XML structure input, we want to convert it to the output structs and render it
		// It sucks that we can't do it directly, i guess we could really, but XML and it's associated data structures suck
		// so we eat the cost of the conversion. As this is not for a 'real time' application it doesn't matter anyway
		pbConf := new(pb.Config)
		addHeaderConfig(pbConf)
		pbConf.Name = cfg.Name
		pbConf.BlockNameLower = strings.ToLower(pbConf.Name)
		pbConf.Category = strings.TrimSpace(cfg.Category)
		pbConf.Info = strings.TrimSpace(cfg.Info)
		pbConf.Help = strings.TrimSpace(cfg.Help.Help)
		pbConf.Code.Path = "./" + cfg.Name + ".c"

		//The code block value is only used to send data to the C file render process, it is not used in the yml file
		pbConf.Code.Block = strings.TrimSpace(cfg.Function.Function)

		//I/O/V data
		for _, v := range cfg.Data.Variables {
			if v.Socket == "in" {
				i := new(pb.Input)
				i.Info = v.Info
				i.Editable = v.Editable
				if v.Value == "" {
					v.Value = "0"
				}
				i.Value = v.Value
				pbConf.Inputs = append(pbConf.Inputs, *i)
			} else if v.Socket == "out" {
				o := new(pb.Output)
				o.Info = v.Info
				o.Value = v.Value
				pbConf.Outputs = append(pbConf.Outputs, *o)
			} else {
				//Must be a dtype var
				vr := new(pb.Var)
				vr.Value = v.Value
				vr.Info = v.Info
				vr.Name = v.Name
				vr.Dtype = v.Dtype
				pbConf.Vars = append(pbConf.Vars, *vr)
			}
		}

		return doRenderFromConfig(pbConf)
	},
}

func init() {
	RootCmd.AddCommand(renderCmd)
	renderCmd.AddCommand(confCmd)

	//renderCmd.PersistentFlags().String("dir", "", "A directory to generate a block (or blocks from). Defaults to cwd. If set this overrides conf and c flags")
	confCmd.Flags().String("xml", "", "XML file to process. If not provided look for single xml in cwd or fails")
	renderCmd.PersistentFlags().String("cfg", "", "A config yml to generate a block from")
	renderCmd.PersistentFlags().StringArray("macro", []string{}, "Array of files to use for macro inclusion")
	renderCmd.PersistentFlags().Bool("macro-inbuilt", false, "If true include inbuilt macros in c file rendering")

}
